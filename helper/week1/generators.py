# Функция-генератор, или метод-генератор – это функция, или
# метод, содержащая выражение yield. В результате обращения
# к функции генератору возвращается итератор. Значения из ите-
# ратора извлекаются по одному, с помощью его метода __next__().
# При каждом вызове метода __next__() он возвращает результат
# вычисления выражения yield. (Если выражение отсутствует,
# возвращается значение None.) Когда функция-генератор завер-
# шается или выполняет инструкцию return, возбуждается исклю-
# чение StopIteration.
# На практике очень редко приходится вызывать метод __next__()
# или обрабатывать исключение StopIteration. Обычно функция-
# генератор используется в качестве итерируемого объекта. Ни-
# же приводятся две практически эквивалентные функции. Функ-
# ция слева возвращает список, а функция справа возвращает ге-
# нератор.
# # Создает и возвращает список
import sys


def letter_range(a, z):
    result = []
    while ord(a) < ord(z):
        result.append(a)
        a = chr(ord(a) + 1)
    return result

# Возвращает каждое
# значение по требованию
def letter_range(a, z):
    while ord(a) < ord(z):
        yield a
        a = chr(ord(a) + 1)
list(letter_range("m", "v"))

# Результаты, воспроизводимые обеими функциями, можно обойти
# с помощью цикла for, например for letter in letter_range("m",
# "v"):. Однако когда требуется получить список символов с помо-
# щью функции слева, достаточно просто вызвать ее как let
# ter_range("m", "v"), а для функции справа необходимо выпол-
# нить преобразование: list(letter_range("m", "v")).
# Функции-генераторы и методы-генераторы (а также выраже-
# ния-генераторы) более полно рассматриваются в главе 8.


def items_in_key_order(d):
    for key in sorted(d):
        yield key, d[key]
# equivalent =>
def items_in_key_order(d):
    return ((key, d[key]) for key in sorted(d))


# Выражение yield поочередно возвращает каждое значение вызываю
# щей программе. Кроме того, если будет вызван метод send() генерато
# ра, то переданное значение будет принято функциейгенератором в ка
# честве результата выражения yield. Ниже показано, как можно ис
# пользовать новую функциюгенератор:

def quarters(next_quarter=0.0):
    while True:
        received = (yield next_quarter)
        if received is None:
            next_quarter += 0.25
        else:
            next_quarter = received

result = []
generator = quarters()
while len(result) < 5:
    x = next(generator)
    if abs(x - 0.5) < sys.float_info.epsilon:
        x = generator.send(1.0)
    result.append(x)